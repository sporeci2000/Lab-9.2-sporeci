I handled state updates using React’s useState hook, where the TextInput component triggers an onTextChange callback whenever the user types. This updates the parent component’s state and recalculates statistics in real time. For reading time, I considered an average reading speed of 200 words per minute and divided the word count by 200 to get the estimated time, while capping progress at 100% to avoid visual overflow. To ensure the UI stayed responsive during rapid input, I kept calculations lightweight by using simple string operations like length and split(/\s+/), avoiding unnecessary loops or re-renders. One challenge I faced was accurately counting words and managing edge cases such as extra spaces or empty input, which I solved by trimming the text and filtering empty strings. Another challenge was dynamically validating minimum and maximum word limits without interrupting the typing experience, which I addressed with conditional warnings that update in real time.